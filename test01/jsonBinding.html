<!DOCTYPE html>
<html lang="ko">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="content-language" content="ko">
<meta name="language" content="ko">
<meta property="og:url" content="http://test.tst">
<meta property="og:title" content="타이틀">
<meta property="og:type" content="website">
<meta property="og:description" content="테스트 홈피.">
<meta name="viewport" content="user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, width=device-width">
<meta name="Author" content="">
<meta name="copyright" content="(c)2021">
<meta name="Robots" content="ALL">
<meta name="keywords" content="키워드">
<meta name="description" content="설명">
<title></title>

<link rel="stylesheet" type="text/css" href="../css/common.css">
<script type="text/javascript" id="wiget" src="../as/load_as.js" async=""></script>


<script type="text/javascript" src="../js/jquery-3.4.1.min.js"></script>

<script type="text/javascript" src="../lib/LDebug.js"></script>


<script type="text/javascript">


// json Data binding

// for  객체이름 변경
// DataBinder
const DBinder = (()=>{
	
	//const doc_ = document;
	//const eId_ = document.getElementById;		//document가 생성되기전에 호출됨

	const testCount_ = 10;
	
		
	function tagBind_(id, data){	// id: div id=
		L_(" id:" + id);
		let d = document.getElementById(id);
		let c = d.childNodes||null;
		if(c != null){
			for(let i=0;i<c.length;i++){
				searchDataFor_(i, d.childNodes[i], 0, data);  // idx, obj, level
			}
		}
	}
	
	
	// test
	let dataObj = {aaa: "AAAA", bbb: "bbbb", ccc: "cccc", ddd: "dddd"};

	//
	function nodeInfo_(idx, node, level){
		
		L_( node.nodeName );
		if(node.nodeName == "#text"){
			
			return;
		}
		L_("{level:" + level + " idx::" + idx + " nodeType:" + node.nodeType + " tagName:" + node.tagName);
		L_(node);
		L_("  attr bind:" + node.getAttribute("data-bind")||null);
		L_("  attr data-for:" + node.getAttribute("data-for")||null);
		L_("}");
		
	}


	// attr 중 data-for 를 갯수만큼 생성 해주는 기능
	// 1. data-bind-for 갯수만큼 앞에추가
	// 2. 복사대상은 마지막에 제거
	function searchDataFor_(idx, node, level, data){
			
		//
		//nodeInfo_(idx, node, level);
		
		// do action
		if(node.nodeName == "#text"){
			return;
		}	
			

		if(node.hasAttribute("data-bind-for")){

			// data-for //접근불가
			let forData = node.getAttribute("data-bind-for");
			L_(forData);


			node.removeAttribute("data-bind-for");
			node.removeAttribute("data-bind-for");
			
			
			let newNode = null;
			
			// 생성
			for(let ii=0;ii<5;ii++){		//test
				newNode = node.cloneNode(true);  // deep copy
				newNode.removeAttribute("id");
				newNode.removeAttribute("name");

				newNode.removeAttribute("data-bind-for");		//
				newNode.setAttribute("data-bind-idx", ii);
				newNode.setAttribute("data-bind-item", dataObj);  //obj 들어갈수 있는가??? - 안됨.

				node.parentNode.insertBefore(newNode, node);		// 바로앞에 추가	
			}

			node.remove();
		}

		
		if(node.hasChildNodes()){  // has Child가 있으면
			let level_ = level+1;
			for(let j=0;j<node.childNodes.length;j++){
				searchDataFor_(j, node.childNodes[j], level_, data);
			}
		}
		
	}



	return {
	
		tagBind: function(id, data){

			tagBind_(id, data);
		}		
	}


})();

// Bind comp end



const doc_ = document;
//
document.addEventListener("DOMContentLoaded", function(){  //$(document).ready() 동일한 기능
	L_("Load...");
	
	loadDebug();	


	//
	function loadDebug(){
		
		btnTest("[data-for생성]", (e)=>{
			L_("{{{");
			DBinder.tagBind("addDiv", {});
		});

		btnTest("[getData]", (e)=>{
			let item = $("#addDiv > div > span:nth-child(1)");
			L_(item);
			let data = $(item).attr("data-bind-item");
			L_(data);

			let r = {aa:"aaaa"};
			L_(r
			);

		});


		let count = 0;
		btnTest("[div]중간생성", (e)=>{
			//let doc_ = document.getElementById;  // 접근불가 ?

			L_(doc_.getElementById);

			let middle = doc_.getElementById("middle");

			let node = middle;
			L_(node);

			//같은형태 만들기
			let newNode = node.cloneNode(true);
			node.append(newNode); //
			newNode.removeAttribute("id");		// attribute 속성부분을 옮겨갈수 있음.
			newNode.innerHTML = "<span>{{" + count + "}}</span>";
			++count;
			//

		});

		
		//insertBefore,  insertAfter
		let rCount = 0;
		btnTest("[같은레벨 앞에추가]", (e)=>{
			//let doc_ = document.getElementById;  // 접근불가 ?

			L_(doc_.getElementById);

			let middle = doc_.getElementById("middle");

			let node = middle;
			L_(node);

			//같은형태 만들기
			let newNode = node.cloneNode(true);
			newNode.removeAttribute("id");		//id제거  attribute 속성부분을 옮겨갈수 있음. 

			
			newNode.innerHTML = "<span>{{" + rCount + "}}</span>";
			++rCount;

			//
			let parent = node.parentNode;
			//parent.insertAfter(newNode, node);  // (new, preSibling) insertAfter 함수 없음
			parent.insertBefore(newNode, node);

		});


		btnTest("[middle]제거", (e)=>{
			
			let middle = doc_.getElementById("middle");

		});
		
	}

});	


</script>


</head>


<body>


	<noscript>
	<iframe src="../include/ns.html?id=DateTime" height="0" width="0" style="display:none;visibility:hidden"></iframe>
	</noscript>


	<div id="wrap">
		<div id="_DEBUG_"></div>
	<div>

	<hr/>

	<hr/>

	<div id="addDiv">
		<div>
			[A][B]<span data-bind-for="data.code.list" href="#">{{T1}}</span>[C][D]
		</div>
	</div>

	<div>
		<div>first</div>
		<div id="middle">second</div> <!-- 10 개를 만들어야함 -->
		<div>3</div>
		<div>4</div>
		<div>5</div>
	</div>

	<div>
		<div>JSON data bind</div>

	</div>


	<hr/>


</body>
</html>